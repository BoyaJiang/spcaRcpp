---
title: "Tutorial for spcaRcpp"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial for spcaRcpp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(spcaRcpp)
```

### Simulated Data  
To use the package spcaRcpp, let's first generate some random data.  

```{r}
m <- 10000
V1 <- rnorm(m, -100,200)
V2 <- rnorm(m, -100, 300)
V3 <- -0.1*V1 + 0.1*V2 + rnorm(m, 0, 100)

X <- cbind(V1,V1,V1,V1, V2,V2,V2,V2, V3,V3)
X <- X + matrix(rnorm(length(X),0,1), ncol = ncol(X), nrow = nrow(X))
```

In order to approximate the ``k = 3`` ranks we can use the following code.  
```{r}
rcpp_out = spcaRcpp(X, k = 3, alpha = 0, beta = 0, max_iter = 10000,center = TRUE)
print (rcpp_out)
```

We can compare the results to a similar spca function in an existing
cran package ``sparsepca``:  
```{r}
if(!require(sparsepca)) install.packages("sparsepca",repos = "http://cran.us.r-project.org")
if(!require(Matrix)) install.packages("Matrix",repos = "http://cran.us.r-project.org")
library(sparsepca)
library(Matrix)
spca_out = sparsepca::spca(X, k = 3, alpha = 0, beta = 0, center = TRUE, scale = FALSE, verbose = FALSE)
```

### Accuracy
The spcaRcpp and sparsepca::spca should return the same values for
standard deviations, variance, loadings, eigenvalues, and centers.  
```{r}
all.equal(spca_out$sdev, rcpp_out$sdev)
all.equal(spca_out$var, rcpp_out$var)
all.equal(spca_out$loadings, rcpp_out$loadings)
all.equal(spca_out$eigenvalues, rcpp_out$eigenvalues)
all.equal(spca_out$center, rcpp_out$center)
```

### Efficiency
We can test the efficiency of the new function via ``mircobenchmark``.  
```{r}
library(microbenchmark)
library(ggplot2)
runtime = microbenchmark::microbenchmark(spca_out, rcpp_out, times = 200)
autoplot(runtime)
```

Although the RcppArmadillo integration for iteration loop in the spcaRcpp function was 
expected to increase efficiency, microbenchmark did not show marginally better runtime. 
This could be because the iteration loop did not significantly impact the runtime of
function. As the number of iteration required for convergence increases, the spcaRcpp should
improve efficiency.  

### Comparing to Deterministic PCA
Many are probably more familiar with the ``prcomp`` function in stats R, which performs the 
deterministic PCA on a given data matrix. Note that by setting ``alpha = 0`` and ``beta = 0``, the ``spcaRcpp`` function returns the same results as ``prcomp``.

```{r}
prcomp_out = prcomp(X, center = TRUE, rank. = 3)

all.equal(prcomp_out$sdev[1:3], rcpp_out$sdev)
all.equal(prcomp_out$rotation, rcpp_out$loadings, check.attributes = FALSE)
all.equal(spca_out$center, rcpp_out$center)
```

### Real Data
```{r}
library(tidyverse, quietly = TRUE)
data("USArrests")
head(USArrests)
```
We can test ``spcaRcpp`` on the real USArrests data, and compare the results 
with those generated by ``sparsepca::spca``.  
```{r}
rcpp_out2 = spcaRcpp(USArrests,k = 4, center = TRUE, alpha = 0, beta = 0)
spca_out2 = sparsepca::spca(USArrests,k = 4, center = TRUE, alpha = 0, beta = 0)
rcpp_out2
spca_out2
```

```{r}
all.equal(spca_out2$sdev, rcpp_out2$sdev)
all.equal(spca_out2$var, rcpp_out2$var)
all.equal(spca_out2$loadings, rcpp_out2$loadings)
all.equal(spca_out2$eigenvalues, rcpp_out2$eigenvalues)
all.equal(spca_out2$center, rcpp_out2$center)
```
```{r}
runtime = microbenchmark::microbenchmark(spca_out2, rcpp_out2, times = 200)
autoplot(runtime)
```

